// Code generated by Kitex v0.12.1. DO NOT EDIT.

package userservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	user "github.com/lzl-here/bt-shop-backend/protobuf/kitex_gen/user"
	proto "google.golang.org/protobuf/proto"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"NormalLogin": kitex.NewMethodInfo(
		normalLoginHandler,
		newNormalLoginArgs,
		newNormalLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"NormalRegister": kitex.NewMethodInfo(
		normalRegisterHandler,
		newNormalRegisterArgs,
		newNormalRegisterResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Logout": kitex.NewMethodInfo(
		logoutHandler,
		newLogoutArgs,
		newLogoutResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserInfo": kitex.NewMethodInfo(
		getUserInfoHandler,
		newGetUserInfoArgs,
		newGetUserInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateUserInfo": kitex.NewMethodInfo(
		updateUserInfoHandler,
		newUpdateUserInfoArgs,
		newUpdateUserInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	userServiceServiceInfo                = NewServiceInfo()
	userServiceServiceInfoForClient       = NewServiceInfoForClient()
	userServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return userServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return userServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return userServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "UserService"
	handlerType := (*user.UserService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "user",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.12.1",
		Extra:           extra,
	}
	return svcInfo
}

func normalLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.NormalLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).NormalLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *NormalLoginArgs:
		success, err := handler.(user.UserService).NormalLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*NormalLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newNormalLoginArgs() interface{} {
	return &NormalLoginArgs{}
}

func newNormalLoginResult() interface{} {
	return &NormalLoginResult{}
}

type NormalLoginArgs struct {
	Req *user.NormalLoginReq
}

func (p *NormalLoginArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.NormalLoginReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *NormalLoginArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *NormalLoginArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *NormalLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *NormalLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.NormalLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var NormalLoginArgs_Req_DEFAULT *user.NormalLoginReq

func (p *NormalLoginArgs) GetReq() *user.NormalLoginReq {
	if !p.IsSetReq() {
		return NormalLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NormalLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NormalLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type NormalLoginResult struct {
	Success *user.NormalLoginRsp
}

var NormalLoginResult_Success_DEFAULT *user.NormalLoginRsp

func (p *NormalLoginResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.NormalLoginRsp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *NormalLoginResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *NormalLoginResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *NormalLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *NormalLoginResult) Unmarshal(in []byte) error {
	msg := new(user.NormalLoginRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *NormalLoginResult) GetSuccess() *user.NormalLoginRsp {
	if !p.IsSetSuccess() {
		return NormalLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *NormalLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.NormalLoginRsp)
}

func (p *NormalLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NormalLoginResult) GetResult() interface{} {
	return p.Success
}

func normalRegisterHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.NormalRegisterReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).NormalRegister(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *NormalRegisterArgs:
		success, err := handler.(user.UserService).NormalRegister(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*NormalRegisterResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newNormalRegisterArgs() interface{} {
	return &NormalRegisterArgs{}
}

func newNormalRegisterResult() interface{} {
	return &NormalRegisterResult{}
}

type NormalRegisterArgs struct {
	Req *user.NormalRegisterReq
}

func (p *NormalRegisterArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.NormalRegisterReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *NormalRegisterArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *NormalRegisterArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *NormalRegisterArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *NormalRegisterArgs) Unmarshal(in []byte) error {
	msg := new(user.NormalRegisterReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var NormalRegisterArgs_Req_DEFAULT *user.NormalRegisterReq

func (p *NormalRegisterArgs) GetReq() *user.NormalRegisterReq {
	if !p.IsSetReq() {
		return NormalRegisterArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NormalRegisterArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NormalRegisterArgs) GetFirstArgument() interface{} {
	return p.Req
}

type NormalRegisterResult struct {
	Success *user.NormalRegisterRsp
}

var NormalRegisterResult_Success_DEFAULT *user.NormalRegisterRsp

func (p *NormalRegisterResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.NormalRegisterRsp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *NormalRegisterResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *NormalRegisterResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *NormalRegisterResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *NormalRegisterResult) Unmarshal(in []byte) error {
	msg := new(user.NormalRegisterRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *NormalRegisterResult) GetSuccess() *user.NormalRegisterRsp {
	if !p.IsSetSuccess() {
		return NormalRegisterResult_Success_DEFAULT
	}
	return p.Success
}

func (p *NormalRegisterResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.NormalRegisterRsp)
}

func (p *NormalRegisterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NormalRegisterResult) GetResult() interface{} {
	return p.Success
}

func logoutHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.LogoutReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).Logout(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *LogoutArgs:
		success, err := handler.(user.UserService).Logout(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LogoutResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newLogoutArgs() interface{} {
	return &LogoutArgs{}
}

func newLogoutResult() interface{} {
	return &LogoutResult{}
}

type LogoutArgs struct {
	Req *user.LogoutReq
}

func (p *LogoutArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.LogoutReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *LogoutArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *LogoutArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *LogoutArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *LogoutArgs) Unmarshal(in []byte) error {
	msg := new(user.LogoutReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LogoutArgs_Req_DEFAULT *user.LogoutReq

func (p *LogoutArgs) GetReq() *user.LogoutReq {
	if !p.IsSetReq() {
		return LogoutArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LogoutArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *LogoutArgs) GetFirstArgument() interface{} {
	return p.Req
}

type LogoutResult struct {
	Success *user.LogoutRsp
}

var LogoutResult_Success_DEFAULT *user.LogoutRsp

func (p *LogoutResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.LogoutRsp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *LogoutResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *LogoutResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *LogoutResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *LogoutResult) Unmarshal(in []byte) error {
	msg := new(user.LogoutRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LogoutResult) GetSuccess() *user.LogoutRsp {
	if !p.IsSetSuccess() {
		return LogoutResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LogoutResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LogoutRsp)
}

func (p *LogoutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LogoutResult) GetResult() interface{} {
	return p.Success
}

func getUserInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.GetUserInfoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).GetUserInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserInfoArgs:
		success, err := handler.(user.UserService).GetUserInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserInfoArgs() interface{} {
	return &GetUserInfoArgs{}
}

func newGetUserInfoResult() interface{} {
	return &GetUserInfoResult{}
}

type GetUserInfoArgs struct {
	Req *user.GetUserInfoReq
}

func (p *GetUserInfoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.GetUserInfoReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetUserInfoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetUserInfoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetUserInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserInfoArgs) Unmarshal(in []byte) error {
	msg := new(user.GetUserInfoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserInfoArgs_Req_DEFAULT *user.GetUserInfoReq

func (p *GetUserInfoArgs) GetReq() *user.GetUserInfoReq {
	if !p.IsSetReq() {
		return GetUserInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserInfoResult struct {
	Success *user.GetUserInfoRsp
}

var GetUserInfoResult_Success_DEFAULT *user.GetUserInfoRsp

func (p *GetUserInfoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.GetUserInfoRsp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetUserInfoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetUserInfoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetUserInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserInfoResult) Unmarshal(in []byte) error {
	msg := new(user.GetUserInfoRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserInfoResult) GetSuccess() *user.GetUserInfoRsp {
	if !p.IsSetSuccess() {
		return GetUserInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.GetUserInfoRsp)
}

func (p *GetUserInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserInfoResult) GetResult() interface{} {
	return p.Success
}

func updateUserInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.UpdateUserInfoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).UpdateUserInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateUserInfoArgs:
		success, err := handler.(user.UserService).UpdateUserInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateUserInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateUserInfoArgs() interface{} {
	return &UpdateUserInfoArgs{}
}

func newUpdateUserInfoResult() interface{} {
	return &UpdateUserInfoResult{}
}

type UpdateUserInfoArgs struct {
	Req *user.UpdateUserInfoReq
}

func (p *UpdateUserInfoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(user.UpdateUserInfoReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateUserInfoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateUserInfoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateUserInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateUserInfoArgs) Unmarshal(in []byte) error {
	msg := new(user.UpdateUserInfoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateUserInfoArgs_Req_DEFAULT *user.UpdateUserInfoReq

func (p *UpdateUserInfoArgs) GetReq() *user.UpdateUserInfoReq {
	if !p.IsSetReq() {
		return UpdateUserInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateUserInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateUserInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateUserInfoResult struct {
	Success *user.UpdateUserInfoRsp
}

var UpdateUserInfoResult_Success_DEFAULT *user.UpdateUserInfoRsp

func (p *UpdateUserInfoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(user.UpdateUserInfoRsp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateUserInfoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateUserInfoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateUserInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateUserInfoResult) Unmarshal(in []byte) error {
	msg := new(user.UpdateUserInfoRsp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateUserInfoResult) GetSuccess() *user.UpdateUserInfoRsp {
	if !p.IsSetSuccess() {
		return UpdateUserInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateUserInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.UpdateUserInfoRsp)
}

func (p *UpdateUserInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateUserInfoResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) NormalLogin(ctx context.Context, Req *user.NormalLoginReq) (r *user.NormalLoginRsp, err error) {
	var _args NormalLoginArgs
	_args.Req = Req
	var _result NormalLoginResult
	if err = p.c.Call(ctx, "NormalLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) NormalRegister(ctx context.Context, Req *user.NormalRegisterReq) (r *user.NormalRegisterRsp, err error) {
	var _args NormalRegisterArgs
	_args.Req = Req
	var _result NormalRegisterResult
	if err = p.c.Call(ctx, "NormalRegister", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Logout(ctx context.Context, Req *user.LogoutReq) (r *user.LogoutRsp, err error) {
	var _args LogoutArgs
	_args.Req = Req
	var _result LogoutResult
	if err = p.c.Call(ctx, "Logout", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserInfo(ctx context.Context, Req *user.GetUserInfoReq) (r *user.GetUserInfoRsp, err error) {
	var _args GetUserInfoArgs
	_args.Req = Req
	var _result GetUserInfoResult
	if err = p.c.Call(ctx, "GetUserInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateUserInfo(ctx context.Context, Req *user.UpdateUserInfoReq) (r *user.UpdateUserInfoRsp, err error) {
	var _args UpdateUserInfoArgs
	_args.Req = Req
	var _result UpdateUserInfoResult
	if err = p.c.Call(ctx, "UpdateUserInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
